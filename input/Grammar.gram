<compilation unit> ::= <package declaration>? <import declarations>? <type declarations>?
<package declaration> ::= package <package name> ;
<import declarations> ::= <import declaration> <import declarations1>
<import declarations1> ::= <import declarations> | <empty>
<import declaration> ::= <single type import declaration> | <type import on demand declaration>
<single type import declaration> ::= import <type name> ;
<type import on demand declaration> ::= import <package name> . * ;
<type declarations> ::= <type declaration> <type declarations1>
<type declarations1> ::= <type declarations> | <empty>
<type declaration> ::= <class declaration> | <interface declaration> | ;
<class declaration> ::= <class modifiers>? class <identifier> <super>? <interfaces>? <class body>
<class modifiers> ::= <class modifier> <class modifiers1>
<class modifiers1> ::= <class modifiers> | <empty>
<class modifier> ::= public | abstract | final | static
<super> ::= extends <class type>
<interfaces> ::= implements <interface type list>
<interface type list> ::= <interface type> <interface type list1>
<interface type list1> ::= , <interface type list> | <empty>
<class body> ::= { <class body declarations>? }
<class body declarations> ::= <class body declaration> <class body declarations1>
<class body declarations1> ::= <class body declarations> | <empty>
<class body declaration> ::= <class member declaration> | <static initializer> | <constructor declaration>
<class member declaration> ::= <field declaration> | <method declaration> | <class declaration>
<static initializer> ::= static <block>
<constructor declaration> ::= <constructor modifiers>? <constructor declarator> <throws>? <constructor body>
<constructor modifiers> ::= <constructor modifier> <constructor modifiers1>
<constructor modifiers1> ::= <constructor modifiers> | <empty>
<constructor modifier> ::= public | protected | private
<constructor declarator> ::= <simple type name> ( <formal parameter list>? )
<formal parameter list> ::= <formal parameter> <formal parameter list1>
<formal parameter list1> ::= , <formal parameter list> | <empty>
<formal parameter> ::= <type> <variable declarator id>
<throws> ::= throws <class type list>
<class type list> ::= <class type> <class type list1>
<class type list1> ::= , <class type list> | <empty>
<constructor body> ::= { <explicit constructor invocation>? <block statements>? }
<explicit constructor invocation>::= this ( <argument list>? ) | super ( <argument list>? )
<field declaration> ::= <field modifiers>? <type> <variable declarators> ;
<field modifiers> ::= <field modifier> <field modifiers1>
<field modifiers1> ::= <field modifiers> | <empty>
<field modifier> ::= public | protected | private | static | final | transient | volatile
<variable declarators> ::= <variable declarator> <variable declarators1>
<variable declarators1> ::= , <variable declarators> | <empty>
<variable declarator> ::= <variable declarator id> <variable declarator1>
<variable declarator1> ::=  = <variable initializer> | <empty>
<variable declarator id> ::= <identifier> <variable declarator id1>
<variable declarator id1> ::= [ ] <variable declarator id1> | <empty>
<method declaration> ::= <method header> <method body>
<method header> ::= <method modifiers>? <result type> <method declarator> <throws>?
<result type> ::= <type> | void
<method modifiers> ::= <method modifier> <method modifiers1>
<method modifiers1> ::= <method modifiers> | <empty>
<method modifier> ::= public | protected | private | static | abstract | final | synchronized | native
<method declarator> ::= <identifier> ( <formal parameter list>? )
<method body> ::= <block> | ;
<interface declaration> ::= <interface modifiers>? interface <identifier> <extends interfaces>? <interface body>
<interface modifiers> ::= <interface modifier> <interface modifiers1> 
<interface modifiers1> ::= <interface modifiers> | <empty>
<interface modifier> ::= public | abstract
<extends interfaces> ::= extends <interface type> | <extends interfaces> , <interface type>
<interface body> ::= { <interface member declarations>? }
<interface member declarations> ::= <interface member declaration> <interface member declarations1>
<interface member declarations1> ::= <interface member declarations> | <empty>
<interface member declaration> ::= <constant declaration> | <abstract method declaration>
<constant declaration> ::= <constant modifiers> <type> <variable declarator>
<constant modifiers> ::= public | static | final
<abstract method declaration>::= <abstract method modifiers>? <result type> <method declarator> <throws>? ;
<abstract method modifiers> ::= <abstract method modifier> <abstract method modifiers1>
<abstract method modifiers1> ::= <abstract method modifiers> | <empty>
<abstract method modifier> ::= public | abstract
<array initializer> ::= { <variable initializers>? ,? }
<variable initializers> ::= <variable initializer> <variable initializers1>
<variable initializers1> ::= , <variable initializers> | <empty>
<variable initializer> ::= <expression> | <array initializer>
<type> ::= <primitive type> <type1> | <class or interface type> <type1> 
<type1> ::= [ ] <type1> | <empty>
<primitive type> ::= <numeric type> | boolean
<numeric type> ::= <integral type> | <floating-point type>
<integral type> ::= byte | short | int | long | char
<floating-point type> ::= float | double
<reference type> ::= <class or interface type> | <array type>
<class or interface type> ::= <class type> | <interface type>
<class type> ::= <type name>
<interface type> ::= <type name>
<array type> ::= <type> [ ]
<block> ::= { <block statements>? }
<block statements> ::= <block statement> <block statements1>
<block statements1> ::= <block statements> | <empty>
<block statement> ::= <local variable declaration statement> | <statement>
<local variable declaration statement> ::= <local variable declaration> ;
<local variable declaration> ::= <type> <variable declarators>
<statement> ::= <statement without trailing substatement> | <labeled statement> | <if then statement> | <if then else statement> | <while statement> | <for statement>
<statement no short if> ::= <statement without trailing substatement> | <labeled statement no short if> | <if then else statement no short if> | <while statement no short if> | <for statement no short if>
<statement without trailing substatement> ::= <block> | <empty statement> | <expression statement> | <switch statement> | <do statement> | <break statement> | <continue statement> | <return statement> | <synchronized statement> | <throws statement> | <try statement>
<empty statement> ::= ;
<labeled statement> ::= <identifier> : <statement>
<labeled statement no short if> ::= <identifier> : <statement no short if>
<expression statement> ::= <statement expression> ;
<statement expression> ::= <assignment> | <preincrement expression> | <postincrement expression> | <predecrement expression> | <postdecrement expression> | <method invocation> | <class instance creation expression>
<if then statement>::= if ( <expression> ) <statement>
<if then else statement>::= if ( <expression> ) <statement no short if> else <statement>
<if then else statement no short if> ::= if ( <expression> ) <statement no short if> else <statement no short if>
<switch statement> ::= switch ( <expression> ) <switch block>
<switch block> ::= { <switch block statement groups>? <switch labels>? }
<switch block statement groups> ::= <switch block statement group> <switch block statement groups1>
<switch block statement groups1> ::= <switch block statement groups> | <empty>
<switch block statement group> ::= <switch labels> <block statements>
<switch labels> ::= <switch label> <switch labels1>
<switch labels1> ::= <switch labels> | <empty>
<switch label> ::= case <constant expression> : | default :
<while statement> ::= while ( <expression> ) <statement>
<while statement no short if> ::= while ( <expression> ) <statement no short if>
<do statement> ::= do <statement> while ( <expression> ) ;
<for statement> ::= for ( <for init>? ; <expression>? ; <for update>? ) <statement>
<for statement no short if> ::= for ( <for init>? ; <expression>? ; <for update>? ) <statement no short if>
<for init> ::= <statement expression list> | <local variable declaration>
<for update> ::= <statement expression list>
<statement expression list> ::= <statement expression> <statement expression list1>
<statement expression list1> ::= , <statement expression list> | <empty>
<break statement> ::= break <identifier>? ;
<continue statement> ::= continue <identifier>? ;
<return statement> ::= return <expression>? ;
<throws statement> ::= throw <expression> ;
<synchronized statement> ::= synchronized ( <expression> ) <block>
<try statement> ::= try <block> <catches> | try <block> <catches>? <finally>
<catches> ::= <catch clause> <catches1> 
<catches1> ::= <catches> | <empty>
<catch clause> ::= catch ( <formal parameter> ) <block>
<finally > ::= finally <block>
<constant expression> ::= <expression>
<expression> ::= <assignment expression>
<assignment expression> ::= <conditional expression> | <assignment>
<assignment> ::= <left hand side> <assignment operator> <assignment expression>
<left hand side> ::= <field access> | <array access> | <expression name> 
<assignment operator> ::= = | *= | /= | %= | += | -= | <<= | >>= | >>>= | &= | ^= | `=
<conditional expression> ::= <conditional or expression> <conditional expression1>
<conditional expression1> ::= ? <expression> : <conditional expression> | <empty>
<conditional or expression> ::= <conditional and expression> <conditional or expression1>
<conditional or expression1> ::= `` <conditional or expression> | <empty>
<conditional and expression> ::= <inclusive or expression> <conditional and expression1>
<conditional and expression1> ::= && <conditional and expression> | <empty>
<inclusive or expression> ::= <exclusive or expression> <inclusive or expression1>
<inclusive or expression1> ::= ` <inclusive or expression> | <empty>
<exclusive or expression> ::= <and expression> <exclusive or expression1>
<exclusive or expression1> ::= ^ <exclusive or expression> | <empty>
<and expression> ::= <equality expression> <and expression1>
<and expression1> ::= & <and expression> | <empty>
<equality expression> ::= <relational expression> <equality expression1>
<equality expression1> ::= == <equality expression> | != <equality expression> | <empty>
<relational expression> ::= <shift expression> <relational expression1>
<relational expression1> ::= @ <shift expression> <relational expression1> | # <shift expression> <relational expression1> | @= <shift expression> <relational expression1> | #= <shift expression> <relational expression1> | instanceof <reference type> <relational expression1> | <empty>
<shift expression> ::= <additive expression> <shift expression1>
<shift expression1> ::= @@ <shift expression> | ## <shift expression> | ### <shift expression> | <empty>
<additive expression> ::= <multiplicative expression> <additive expression1>
<additive expression1> ::= + <multiplicative expression> <additive expression1> | - <multiplicative expression> <additive expression1> | <empty>
<multiplicative expression> ::= <unary expression> <multiplicative expression1>
<multiplicative expression1> ::=  * <unary expression> <multiplicative expression1> | / <unary expression> <multiplicative expression1> | % <unary expression> <multiplicative expression1> | <empty>
<cast expression> ::= ( <primitive type> ) <unary expression> | ( <reference type> ) <unary expression not plus minus>
<unary expression> ::= <preincrement expression> | <predecrement expression> | + <unary expression> | - <unary expression> | <unary expression not plus minus>
<predecrement expression> ::= -- <unary expression>
<preincrement expression> ::= ++ <unary expression>
<unary expression not plus minus> ::= <postfix expression> | ~ <unary expression> | ! <unary expression> | <cast expression>
<postdecrement expression> ::= <postfix expression>
<postincrement expression> ::= <postfix expression>
<postfix expression> ::= <primary> <postfix expression1> | <expression name> <postfix expression1>
<postfix expression1> ::= ++ <postfix expression1> | -- <postfix expression1> | <empty>
<method invocation> ::= <method name> ( <argument list>? ) | <primary> . <identifier> ( <argument list>? ) | super . <identifier> ( <argument list>? )
<field access> ::= <primary> . <identifier> | super . <identifier>
<primary> ::= <array creation expression> | <primary no new array> 
<primary no new array> ::= <literal> <primary no new array1>| this <primary no new array1>| ( <expression> ) <primary no new array1> | <class instance creation expression> <primary no new array1> | <array creation expression> . <identifier> ( <argument list>? ) <primary no new array1> | <array creation expression> . <identifier> <primary no new array1> | super . <identifier> <primary no new array1> | <method name> ( <argument list>? ) <primary no new array1> | super . <identifier> ( <argument list>? ) <primary no new array1> | <expression name> [ <expression> ] <primary no new array1>
<primary no new array1> ::= . <identifier> <primary no new array1> | [ <expression>] <primary no new array1> | <empty> 
<class instance creation expression> ::= new <class type> ( <argument list>? )
<argument list> ::= <expression> <argument list1>
<argument list1> ::= , <argument list> | <empty>
<array creation expression> ::= new <primitive type> <dim exprs> <dims>? | new <class or interface type> <dim exprs> <dims>?
<dim exprs> ::= <dim expr> <dim exprs1>
<dim exprs1> ::= <dim exprs> | <empty>
<dim expr> ::= [ <expression> ]
<dims> ::= [ ] <dims> | [ ]
<array access> ::= <expression name> [ <expression> ] | <primary no new array> [ <expression>]
<package name> ::= <identifier> <package name1> 
<package name1> ::= . <package name> | <empty> 
<type name> ::= <identifier> <type name1>  
<type name1> ::= . <package name> | <empty>  
<simple type name> ::= <identifier>
<expression name> ::= <identifier> <expression name1>
<expression name1> ::= . <ambiguous name> | <empty>
<method name> ::= <identifier> <method name1>
<method name1> ::= . <ambiguous name> | <empty>
<ambiguous name>::= <identifier> <ambiguous name1>
<ambiguous name1>::= . <ambiguous name> | <empty>
<literal> ::= <floating-point literal> | <integer literal> | <boolean literal> | <character literal> | <string literal> | <null literal>
<integer literal> ::= <decimal integer literal> | <hex integer literal> | <octal integer literal>
<decimal integer literal> ::= <decimal numeral> <integer type suffix>?
<hex integer literal> ::= <hex numeral> <integer type suffix>?
<octal integer literal> ::= <octal numeral> <integer type suffix>?
<integer type suffix> ::= l | L
<decimal numeral> ::= 0 | <non zero digit> <digits>?
<digits> ::= <digit> <digits1>
<digits1> ::= <digits> | <empty>
<digit> ::= 0 | <non zero digit>
<non zero digit> ::= 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
<hex numeral> ::= 0 x <hex digit> <hex numeral1> | 0 X <hex digit> <hex numeral1>
<hex numeral1> ::= <hex digit> <hex numeral1> | <empty> 
<hex digit> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | a | b | c | d | e | f | A | B | C | D | E | F
<octal numeral> ::= 0 <octal digit> <octal numeral1> 
<octal numeral1> ::= <octal digit> <octal numeral1> | <empty> 
<octal digit> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7
<floating-point literal> ::= <digits> .? <digits>? <exponent part>? <float type suffix>?
<exponent part> ::= <exponent indicator> <signed integer>
<exponent indicator> ::= e | E
<signed integer> ::= <sign>? <digits>
<sign> ::= + | -
<float type suffix> ::= f | F | d | D
<boolean literal> ::= true | false
<null literal> ::= null
<keyword> ::= abstract | boolean | break | byte | case | catch | char | class | const | continue | default | do | double | else | extends | final | finally | float | for | goto | if | implements | import | instanceof | int | interface | long | native | new | package | private | protected | public | return | short | static | super | switch | synchronized | this | throw | throws | transient | try | void | volatile | while